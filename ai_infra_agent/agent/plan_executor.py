import asyncio
import re
import json
from datetime import date, datetime
from typing import Dict, Any, List

from fastapi import WebSocket
from loguru import logger

from ai_infra_agent.agent.agent import StateAwareAgent

# --- Helper Function ---
def json_serializer(obj: Any) -> str:
    """
    Custom JSON serializer for objects not serializable by default, like datetime.
    Converts datetime objects to ISO 8601 string format.
    """
    if isinstance(obj, (datetime, date)):
        return obj.isoformat()
    raise TypeError(f"Type {type(obj)} not serializable for JSON")


class PlanExecutor:
    """
    Orchestrates the step-by-step execution of a plan generated by the AI agent.
    This class is responsible for resolving dependencies between steps, executing tools,
    managing the execution context, and sending real-time updates via WebSocket.
    """

    def __init__(self, agent: StateAwareAgent, websocket: WebSocket, logger: logger):
        """
        Initializes the PlanExecutor.

        Args:
            agent (StateAwareAgent): The agent instance, used to execute tools.
            websocket (WebSocket): The active WebSocket connection for sending updates.
            logger: The logger instance.
        """
        self.agent = agent
        self.websocket = websocket
        self.logger = logger
        self.context: Dict[str, Any] = {}

    async def _send_update(self, data: Dict[str, Any]) -> None:
        """Sends a JSON message to the client via WebSocket using the custom serializer."""
        await self.websocket.send_text(json.dumps(data, default=json_serializer))

    def _get_value_from_context(self, path: str) -> Any:
        """
        Retrieves a value from the context using a dot-separated path.
        Example: "step-id.output_key.nested_key[0]"
        """
        keys = re.split(r'\.|\[|\]', path)
        keys = [k for k in keys if k]  # Remove empty strings

        value = self.context
        for i, key in enumerate(keys):
            try:
                if isinstance(value, list) and key.isdigit():
                    value = value[int(key)]
                elif isinstance(value, dict):
                    try:
                        value = value[key]
                    except KeyError:
                        # Special handling for image_id/ami_id discrepancy
                        if key == "image_id" and "ami_id" in value:
                            value = value["ami_id"]
                        elif key == "ami_id" and "image_id" in value:
                            value = value["image_id"]
                        else:
                            # Try converting snake_case to camelCase for common AWS identifiers
                            camel_case_key = "".join(word.capitalize() if i > 0 else word for i, word in enumerate(key.split('_')))
                            if camel_case_key in value:
                                value = value[camel_case_key]
                            else:
                                # If still not found, try converting camelCase to snake_case
                                snake_case_key = re.sub(r'([A-Z])', r'_\1', key).lower()
                                if snake_case_key in value:
                                    value = value[snake_case_key]
                                else:
                                    raise  # Re-raise if neither snake_case nor camelCase works
                else:
                    raise KeyError(f"Cannot access key '{key}' on non-dict/list value.")
            except (KeyError, IndexError, TypeError) as e:
                self.logger.error(f"Could not resolve path '{path}' in context. Failed at key '{key}'.")
                raise ValueError(f"Could not resolve variable path '{path}' in context. Error: {e}")
        return value

    def _resolve_placeholders_recursively(self, data: Any) -> Any:
        """
        Recursively traverses a data structure (dict, list) and resolves all placeholders in strings.
        """
        if isinstance(data, dict):
            return {key: self._resolve_placeholders_recursively(value) for key, value in data.items()}
        elif isinstance(data, list):
            return [self._resolve_placeholders_recursively(item) for item in data]
        elif isinstance(data, str):
            # First, handle the timestamp placeholder
            timestamp_placeholders = re.findall(r"(\{\{timestamp\}\}|\{timestamp\})", data)
            if timestamp_placeholders:
                timestamp = datetime.utcnow().strftime("%Y%m%d%H%M%S")
                for placeholder in set(timestamp_placeholders):
                    data = data.replace(placeholder, timestamp)

            # Second, handle context variable placeholders
            def resolve_match(match):
                path = match.group(1) or match.group(2)
                if path:
                    try:
                        return str(self._get_value_from_context(path))
                    except (ValueError, KeyError) as e:
                        self.logger.warning(f"Could not resolve placeholder {match.group(0)}: {e}")
                        return match.group(0)  # Return original placeholder on failure
                return match.group(0)

            return re.sub(r"\{\{([^{}]+?)\}\}|\{([^{}]+?)\}", resolve_match, data)
        else:
            return data

    async def execute_plan(self, execution_plan: List[Dict[str, Any]]) -> None:
        """
        The main method to execute a given plan. It iterates through steps,
        handles dependencies (in the future), and sends updates.

        Args:
            execution_plan (List[Dict[str, Any]]): The list of steps to execute.
        """
        await self._send_update({"status": "Executing", "message": "Plan execution started"})
        self.logger.info("Plan execution started. Processing steps...")

        # --- FUTURE ENHANCEMENT ---
        # This is where a proper DAG (Directed Acyclic Graph) solver would go.
        # It would analyze `dependsOn` fields to determine the execution order
        # and run independent steps in parallel using asyncio.gather().
        # For the MVP, we assume the plan is pre-sorted and run sequentially.
        
        for step in execution_plan:
            step_id = step.get("id")
            step_name = step.get("name", "Unnamed Step")
            tool_name = step.get("mcpTool")
            tool_params = step.get("toolParameters", {})

            if not all([step_id, tool_name]):
                raise ValueError(f"Step is missing required fields 'id' or 'mcpTool': {step}")

            self.logger.info(f"--- Preparing to execute step: '{step_name}' (ID: {step_id}) ---")
            await self._send_update({
                "status": "Executing Step",
                "step": step_name,
                "message": f"Executing step: {step_name}"
            })

            try:
                # 1. Resolve parameters for the current step using the new recursive method
                resolved_params = self._resolve_placeholders_recursively(tool_params)
                self.logger.info(f"Executing tool '{tool_name}' with resolved params: {resolved_params}")
                
                # 2. Execute the tool via the agent
                result = await self.agent.execute_tool(tool_name, **resolved_params)
                
                # 3. Store the result in the context for subsequent steps
                self.context[step_id] = result
                self.logger.info(f"Step '{step_name}' completed. Result stored in context for ID '{step_id}'.")
                self.logger.debug(f"Context after step '{step_id}': {self.context}")

                # 4. Send success update to the client
                await self._send_update({
                    "status": "Step Completed",
                    "step": step_name,
                    "result": result
                })

            except Exception as e:
                self.logger.error(f"Execution failed at step '{step_name}': {e}", exc_info=True)
                await self._send_update({
                    "status": "Step Failed",
                    "step": step_name,
                    "error": str(e)
                })
                # Re-raise the exception to stop the entire plan execution
                raise

        await self._send_update({
            "status": "Execution Completed Successfully",
            "message": "All plan steps executed successfully."
        })
        self.logger.info("Plan execution finished successfully.")