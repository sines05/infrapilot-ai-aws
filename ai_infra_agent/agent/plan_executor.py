import asyncio
import re
import json
from datetime import date, datetime
from typing import Dict, Any, List

from fastapi import WebSocket
from loguru import logger

from ai_infra_agent.agent.agent import StateAwareAgent

# --- Helper Function ---
def json_serializer(obj: Any) -> str:
    """
    Custom JSON serializer for objects not serializable by default, like datetime.
    Converts datetime objects to ISO 8601 string format.
    """
    if isinstance(obj, (datetime, date)):
        return obj.isoformat()
    raise TypeError(f"Type {type(obj)} not serializable for JSON")


class PlanExecutor:
    """
    Orchestrates the step-by-step execution of a plan generated by the AI agent.
    This class is responsible for resolving dependencies between steps, executing tools,
    managing the execution context, and sending real-time updates via WebSocket.
    """

    def __init__(self, agent: StateAwareAgent, websocket: WebSocket, logger: logger):
        """
        Initializes the PlanExecutor.

        Args:
            agent (StateAwareAgent): The agent instance, used to execute tools.
            websocket (WebSocket): The active WebSocket connection for sending updates.
            logger: The logger instance.
        """
        self.agent = agent
        self.websocket = websocket
        self.logger = logger
        self.context: Dict[str, Any] = {}

    async def _send_update(self, data: Dict[str, Any]) -> None:
        """Sends a JSON message to the client via WebSocket using the custom serializer."""
        await self.websocket.send_text(json.dumps(data, default=json_serializer))

    async def _resolve_params(self, tool_params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Resolves placeholder variables (e.g., {{step-id.key}}) in the parameters
        of a step using the current execution context.

        Args:
            tool_params (Dict[str, Any]): The raw parameters for a tool call.

        Returns:
            Dict[str, Any]: The parameters with all placeholders replaced by actual values.
        """
        resolved_params = {}
        for key, value in tool_params.items():
            if isinstance(value, str) and value.startswith("{{") and value.endswith("}}"):
                # Handle simple string placeholders
                resolved_params[key] = self._resolve_single_placeholder(value)
            elif isinstance(value, list):
                # Handle lists that may contain placeholders
                resolved_list = []
                for item in value:
                    if isinstance(item, str) and item.startswith("{{") and item.endswith("}}"):
                        resolved_list.append(self._resolve_single_placeholder(item))
                    else:
                        resolved_list.append(item)
                resolved_params[key] = resolved_list
            else:
                # Value is a literal, no resolution needed
                resolved_params[key] = value
        return resolved_params

    def _resolve_single_placeholder(self, placeholder: str) -> Any:
        """
        Resolves a single placeholder string like '{{step-id.data.key[0]}}'.
        
        Args:
            placeholder (str): The placeholder string.
            
        Returns:
            Any: The resolved value from the context.
            
        Raises:
            ValueError: If the path cannot be resolved in the context.
        """
        var_path = placeholder[2:-2].strip()
        self.logger.debug(f"Resolving variable path: '{var_path}'")
        
        # Use regex to split the path, handling array access like [0]
        parts = re.split(r'\.|\[|\]', var_path)
        parts = [p for p in parts if p]  # Remove empty strings from split

        resolved_value = self.context
        for part in parts:
            try:
                if isinstance(resolved_value, dict):
                    resolved_value = resolved_value[part]
                elif isinstance(resolved_value, list) and part.isdigit():
                    resolved_value = resolved_value[int(part)]
                else:
                    raise KeyError(f"Invalid key or index '{part}'")
            except (KeyError, IndexError, TypeError):
                self.logger.error(f"Failed to resolve part '{part}' in path '{var_path}'")
                self.logger.error(f"Current context: {self.context}")
                raise ValueError(f"Could not resolve variable path '{var_path}' in context.")

        self.logger.debug(f"Resolved '{var_path}' to value: {str(resolved_value)[:100]}...")
        return resolved_value


    async def execute_plan(self, execution_plan: List[Dict[str, Any]]) -> None:
        """
        The main method to execute a given plan. It iterates through steps,
        handles dependencies (in the future), and sends updates.

        Args:
            execution_plan (List[Dict[str, Any]]): The list of steps to execute.
        """
        await self._send_update({"status": "Executing", "message": "Plan execution started"})
        self.logger.info("Plan execution started. Processing steps...")

        # --- FUTURE ENHANCEMENT ---
        # This is where a proper DAG (Directed Acyclic Graph) solver would go.
        # It would analyze `dependsOn` fields to determine the execution order
        # and run independent steps in parallel using asyncio.gather().
        # For the MVP, we assume the plan is pre-sorted and run sequentially.
        
        for step in execution_plan:
            step_id = step.get("id")
            step_name = step.get("name", "Unnamed Step")
            tool_name = step.get("mcpTool")
            tool_params = step.get("toolParameters", {})

            if not all([step_id, tool_name]):
                raise ValueError(f"Step is missing required fields 'id' or 'mcpTool': {step}")

            self.logger.info(f"--- Preparing to execute step: '{step_name}' (ID: {step_id}) ---")
            await self._send_update({
                "status": "Executing Step",
                "step": step_name,
                "message": f"Executing step: {step_name}"
            })

            try:
                # 1. Resolve parameters for the current step
                resolved_params = await self._resolve_params(tool_params)
                self.logger.info(f"Executing tool '{tool_name}' with resolved params: {resolved_params}")
                
                # 2. Execute the tool via the agent
                result = await self.agent.execute_tool(tool_name, **resolved_params)
                
                # 3. Store the result in the context for subsequent steps
                self.context[step_id] = result
                self.logger.info(f"Step '{step_name}' completed. Result stored in context for ID '{step_id}'.")
                self.logger.debug(f"Context after step '{step_id}': {self.context}")

                # 4. Send success update to the client
                await self._send_update({
                    "status": "Step Completed",
                    "step": step_name,
                    "result": result
                })

            except Exception as e:
                self.logger.error(f"Execution failed at step '{step_name}': {e}", exc_info=True)
                await self._send_update({
                    "status": "Step Failed",
                    "step": step_name,
                    "error": str(e)
                })
                # Re-raise the exception to stop the entire plan execution
                raise

        await self._send_update({
            "status": "Execution Completed Successfully",
            "message": "All plan steps executed successfully."
        })
        self.logger.info("Plan execution finished successfully.")