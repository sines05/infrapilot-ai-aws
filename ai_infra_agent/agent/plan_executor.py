import asyncio
import re
import json
from datetime import date, datetime
from typing import Dict, Any, List

from fastapi import WebSocket
from loguru import logger

from ai_infra_agent.agent.agent import StateAwareAgent

# --- Helper Function ---
def json_serializer(obj: Any) -> str:
    """
    Custom JSON serializer for objects not serializable by default, like datetime.
    Converts datetime objects to ISO 8601 string format.
    """
    if isinstance(obj, (datetime, date)):
        return obj.isoformat()
    raise TypeError(f"Type {type(obj)} not serializable for JSON")


class PlanExecutor:
    """
    Orchestrates the step-by-step execution of a plan generated by the AI agent.
    This class is responsible for resolving dependencies between steps, executing tools,
    managing the execution context, and sending real-time updates via WebSocket.
    """

    def __init__(self, agent: StateAwareAgent, websocket: WebSocket, logger: logger):
        """
        Initializes the PlanExecutor.

        Args:
            agent (StateAwareAgent): The agent instance, used to execute tools.
            websocket (WebSocket): The active WebSocket connection for sending updates.
            logger: The logger instance.
        """
        self.agent = agent
        self.websocket = websocket
        self.logger = logger
        self.context: Dict[str, Any] = {}

    async def _send_update(self, data: Dict[str, Any]) -> None:
        """Sends a JSON message to the client via WebSocket using the custom serializer."""
        await self.websocket.send_text(json.dumps(data, default=json_serializer))

    def _get_value_from_context(self, path: str) -> Any:
        """
        Retrieves a value from the context using a dot-separated path.
        Example: "step-id.output_key.nested_key[0]"
        """
        keys = re.split(r'\.|\[|\]', path)
        keys = [k for k in keys if k]  # Remove empty strings

        value = self.context
        for i, key in enumerate(keys):
            try:
                if isinstance(value, list) and key.isdigit():
                    value = value[int(key)]
                elif isinstance(value, dict):
                    try:
                        value = value[key]
                    except KeyError:
                        # Special handling for image_id/ami_id discrepancy
                        if key == "image_id" and "ami_id" in value:
                            value = value["ami_id"]
                        elif key == "ami_id" and "image_id" in value:
                            value = value["image_id"]
                        else:
                            # Try converting snake_case to camelCase for common AWS identifiers
                            camel_case_key = "".join(word.capitalize() if i > 0 else word for i, word in enumerate(key.split('_')))
                            if camel_case_key in value:
                                value = value[camel_case_key]
                            else:
                                # If still not found, try converting camelCase to snake_case
                                snake_case_key = re.sub(r'([A-Z])', r'_\1', key).lower()
                                if snake_case_key in value:
                                    value = value[snake_case_key]
                                else:
                                    raise  # Re-raise if neither snake_case nor camelCase works
                else:
                    raise KeyError(f"Cannot access key '{key}' on non-dict/list value.")
            except (KeyError, IndexError, TypeError) as e:
                self.logger.error(f"Could not resolve path '{path}' in context. Failed at key '{key}'.")
                raise ValueError(f"Could not resolve variable path '{path}' in context. Error: {e}")
        return value

    async def _resolve_params(self, tool_params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Resolves placeholder variables (e.g., {{step-id.key}} or {timestamp})
        in the parameters of a step using the current execution context.
        """
        resolved_params = {}
        for key, value in tool_params.items():
            if isinstance(value, str):
                # Process a single string value
                resolved_params[key] = self._resolve_string_placeholders(value)
            elif isinstance(value, list):
                # Process a list of values
                resolved_list = [
                    self._resolve_string_placeholders(item) if isinstance(item, str) else item
                    for item in value
                ]
                resolved_params[key] = resolved_list
            else:
                # Value is a literal, no resolution needed
                resolved_params[key] = value
        return resolved_params

    def _resolve_string_placeholders(self, value: str) -> str:
        """Resolves all placeholders within a single string."""
        self.logger.debug(f"_resolve_string_placeholders: Initial value: {value}")
        # 1. Handle timestamp placeholders first
        timestamp_placeholders = re.findall(r"(\{\{timestamp\}\}|\{timestamp\})", value)
        if timestamp_placeholders:
            timestamp = datetime.utcnow().strftime("%Y%m%d%H%M%S")
            for placeholder in set(timestamp_placeholders):
                value = value.replace(placeholder, timestamp)
            self.logger.debug(f"_resolve_string_placeholders: After timestamp resolution: {value}")

        # 2. Handle context variable placeholders
        def resolve_match(match):
            self.logger.debug(f"resolve_match: Found match: {match.group(0)}")
            # Determine if it's single or double brace and get the path
            path = match.group(1) or match.group(2)
            self.logger.debug(f"resolve_match: Path extracted: {path}")
            if path:
                try:
                    resolved_value = str(self._get_value_from_context(path))
                    self.logger.debug(f"resolve_match: Resolved value from context: {resolved_value}")
                    return resolved_value
                except (ValueError, KeyError) as e:
                    self.logger.warning(f"Could not resolve placeholder {match.group(0)}: {e}")
                    return match.group(0)  # Return original placeholder on failure
            return match.group(0)

        # Regex to find {{path}} or {path}
        value = re.sub(r"\{\{([^{}]+?)\}\}|\{([^{}]+?)\}", resolve_match, value)
        self.logger.debug(f"_resolve_string_placeholders: Final value: {value}")
        return value


    async def execute_plan(self, execution_plan: List[Dict[str, Any]]) -> None:
        """
        The main method to execute a given plan. It iterates through steps,
        handles dependencies (in the future), and sends updates.

        Args:
            execution_plan (List[Dict[str, Any]]): The list of steps to execute.
        """
        await self._send_update({"status": "Executing", "message": "Plan execution started"})
        self.logger.info("Plan execution started. Processing steps...")

        # --- FUTURE ENHANCEMENT ---
        # This is where a proper DAG (Directed Acyclic Graph) solver would go.
        # It would analyze `dependsOn` fields to determine the execution order
        # and run independent steps in parallel using asyncio.gather().
        # For the MVP, we assume the plan is pre-sorted and run sequentially.
        
        for step in execution_plan:
            step_id = step.get("id")
            step_name = step.get("name", "Unnamed Step")
            tool_name = step.get("mcpTool")
            tool_params = step.get("toolParameters", {})

            if not all([step_id, tool_name]):
                raise ValueError(f"Step is missing required fields 'id' or 'mcpTool': {step}")

            self.logger.info(f"--- Preparing to execute step: '{step_name}' (ID: {step_id}) ---")
            await self._send_update({
                "status": "Executing Step",
                "step": step_name,
                "message": f"Executing step: {step_name}"
            })

            try:
                # 1. Resolve parameters for the current step
                resolved_params = await self._resolve_params(tool_params)
                self.logger.info(f"Executing tool '{tool_name}' with resolved params: {resolved_params}")
                
                # 2. Execute the tool via the agent
                result = await self.agent.execute_tool(tool_name, **resolved_params)
                
                # 3. Store the result in the context for subsequent steps
                self.context[step_id] = result
                self.logger.info(f"Step '{step_name}' completed. Result stored in context for ID '{step_id}'.")
                self.logger.debug(f"Context after step '{step_id}': {self.context}")

                # 4. Send success update to the client
                await self._send_update({
                    "status": "Step Completed",
                    "step": step_name,
                    "result": result
                })

            except Exception as e:
                self.logger.error(f"Execution failed at step '{step_name}': {e}", exc_info=True)
                await self._send_update({
                    "status": "Step Failed",
                    "step": step_name,
                    "error": str(e)
                })
                # Re-raise the exception to stop the entire plan execution
                raise

        await self._send_update({
            "status": "Execution Completed Successfully",
            "message": "All plan steps executed successfully."
        })
        self.logger.info("Plan execution finished successfully.")