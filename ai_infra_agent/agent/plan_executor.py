import asyncio
import re
import json
from datetime import date, datetime
from typing import Dict, Any, List

from fastapi import WebSocket
from loguru import logger

from ai_infra_agent.agent.agent import StateAwareAgent
from ai_infra_agent.state.schemas import ResourceState

# --- Helper Functions ---
def json_serializer(obj: Any) -> str:
    """
    Custom JSON serializer for objects not serializable by default, like datetime.
    Converts datetime objects to ISO 8601 string format.
    """
    if isinstance(obj, (datetime, date)):
        return obj.isoformat()
    raise TypeError(f"Type {type(obj)} not serializable for JSON")

def _convert_datetime_to_iso(obj: Any) -> Any:
    """
    Recursively converts datetime objects within a dictionary or list to ISO 8601 strings.
    """
    if isinstance(obj, datetime):
        return obj.isoformat()
    elif isinstance(obj, date):
        return obj.isoformat()
    elif isinstance(obj, dict):
        return {k: _convert_datetime_to_iso(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [_convert_datetime_to_iso(elem) for elem in obj]
    return obj

def _snake_to_pascal_case(snake_str: str) -> str:
    """
    Converts a snake_case string to PascalCase.
    Example: 'db_subnet_group_name' -> 'DBSubnetGroupName'
    """
    components = snake_str.split('_')
    return "".join(x.capitalize() for x in components)


class PlanExecutor:
    """
    Orchestrates the step-by-step execution of a plan generated by the AI agent.
    This class is responsible for resolving dependencies between steps, executing tools,
    managing the execution context, and sending real-time updates via WebSocket.
    """

    def __init__(self, agent: StateAwareAgent, websocket: WebSocket, logger: logger):
        """
        Initializes the PlanExecutor.

        Args:
            agent (StateAwareAgent): The agent instance, used to execute tools.
            websocket (WebSocket): The active WebSocket connection for sending updates.
            logger: The logger instance.
        """
        self.agent = agent
        self.websocket = websocket
        self.logger = logger
        self.context: Dict[str, Any] = {}

    async def _send_update(self, data: Dict[str, Any]) -> None:
        """Sends a JSON message to the client via WebSocket using the custom serializer."""
        await self.websocket.send_text(json.dumps(data, default=json_serializer))

    def _get_value_from_context(self, path: str) -> Any:
        """
        Retrieves a value from the context using a dot-separated path.
        Example: "step-id.output_key.nested_key[0]"
        """
        keys = re.split(r'\.|\[|\]', path)
        keys = [k for k in keys if k]  # Remove empty strings

        value = self.context
        for i, key in enumerate(keys):
            self.logger.debug(f"Current value: {value}, Current key: {key}")
            try:
                if isinstance(value, list) and key.isdigit():
                    value = value[int(key)]
                elif isinstance(value, dict):
                    try:
                        value = value[key] # Try direct access first
                    except KeyError:
                        self.logger.debug(f"KeyError for key: {key}. Attempting casing conversions.")
                        # Special handling for image_id/ami_id discrepancy
                        if key == "image_id" and "ami_id" in value:
                            value = value["ami_id"]
                        elif key == "ami_id" and "image_id" in value:
                            value = value["image_id"]
                        else:
                            # Try converting snake_case to PascalCase (e.g., db_subnet_group_name -> DBSubnetGroupName)
                            pascal_case_from_snake = _snake_to_pascal_case(key)
                            if pascal_case_from_snake in value:
                                value = value[pascal_case_from_snake]
                                self.logger.debug(f"  Found value using PascalCase: {pascal_case_from_snake}")
                            elif key == "group_id" and "groupId" in value:
                                value = value["groupId"]
                                self.logger.debug(f"  Found groupId for key 'group_id'")
                            elif key == "db_subnet_group_name" and ("DBSubnetGroupName" in value or "dbSubnetGroupName" in value or "name" in value):
                                value = value.get("DBSubnetGroupName") or value.get("dbSubnetGroupName") or value.get("name")
                                self.logger.debug(f"  Found DBSubnetGroupName for key 'db_subnet_group_name'")
                            elif key == "vpc_security_group_ids" and isinstance(value, list) and all(isinstance(item, dict) and "groupId" in item for item in value):
                                value = [item["groupId"] for item in value]
                                self.logger.debug(f"  Extracted groupId from list of security groups for 'vpc_security_group_ids'")
                            else:
                                self.logger.debug(f"  snake_to_pascal_case: {key} -> {pascal_case_from_snake}")
                                self.logger.debug(f"  Value keys: {value.keys()}")
                                # If still not found, re-raise the KeyError
                                raise KeyError(f"Key '{key}' not found after casing conversions or special handling.")
                else:
                    raise KeyError(f"Cannot access key '{key}' on non-dict/list value.")
            except (KeyError, IndexError, TypeError) as e:
                self.logger.error(f"Could not resolve path '{path}' in context. Failed at key '{key}'.")
                # Temporarily raise a custom exception with debug info
                debug_info = {
                    "failed_key": key,
                    "current_value_type": type(value).__name__,
                    "current_value_keys": list(value.keys()) if isinstance(value, dict) else None,
                    "attempted_pascal_case": _snake_to_pascal_case(key) if isinstance(value, dict) else None
                }
                raise ValueError(f"Could not resolve variable path '{path}' in context. Debug Info: {debug_info}")
        return value

    def _resolve_placeholders_recursively(self, data: Any) -> Any:
        """
        Recursively traverses a data structure (dict, list) and resolves all placeholders in strings.
        """
        if isinstance(data, dict):
            return {key: self._resolve_placeholders_recursively(value) for key, value in data.items()}
        elif isinstance(data, list):
            return [self._resolve_placeholders_recursively(item) for item in data]
        elif isinstance(data, str):
            # First, handle the timestamp placeholder
            timestamp_placeholders = re.findall(r"(\{\{timestamp\}\}|\{timestamp\})", data)
            if timestamp_placeholders:
                timestamp = datetime.utcnow().strftime("%Y%m%d%H%M%S")
                for placeholder in set(timestamp_placeholders):
                    data = data.replace(placeholder, timestamp)

            # Second, handle context variable placeholders
            # Check if the string is *only* a placeholder
            match = re.fullmatch(r"\{\{([^{}]+?)\}\}|\{([^{}]+?)\}", data)
            if match:
                path = match.group(1) or match.group(2)
                if path:
                    try:
                        # If it's a standalone placeholder, return the raw value
                        return self._get_value_from_context(path)
                    except (ValueError, KeyError) as e:
                        self.logger.warning(f"Could not resolve placeholder {match.group(0)}: {e}")
                        return data  # Return original placeholder on failure
            
            # If not a standalone placeholder, or if it contains other text, resolve and convert to string
            def resolve_match_func(match_obj): # Renamed to avoid conflict with outer 'match'
                path = match_obj.group(1) or match_obj.group(2)
                if path:
                    try:
                        return str(self._get_value_from_context(path))
                    except (ValueError, KeyError) as e:
                        self.logger.warning(f"Could not resolve placeholder {match_obj.group(0)}: {e}")
                        return match_obj.group(0)  # Return original placeholder on failure
                return match_obj.group(0)

            resolved_string = re.sub(r"\{\{([^{}]+?)\}\}|\{([^{}]+?)\}", resolve_match_func, data)
            self.logger.debug(f"Resolved string: {data} -> {resolved_string}")
            return resolved_string
        else:
            return data

            

    def _update_state_after_creation(self, tool_name: str, result: Dict[str, Any]):
        """
        Transforms the result of a creation tool into a ResourceState object and saves it.
        This is a simplified implementation and should be expanded.
        """
        resource_type = "unknown"
        resource_id = None
        resource_name = ""
        
        # Convert all datetime objects in the result to ISO format before storing
        properties = _convert_datetime_to_iso(result)

        if tool_name == "create-ec2-instance" and result.get("Instances"):
            instance_info = result["Instances"][0]
            resource_type = "aws_ec2_instance"
            resource_id = instance_info.get("InstanceId")
            resource_name = resource_id  # Default name to id
            for tag in instance_info.get("Tags", []):
                if tag["Key"] == "Name":
                    resource_name = tag["Value"]
                    break
        elif tool_name == "create-security-group" and result.get("GroupId"):
            resource_type = "aws_security_group"
            resource_id = result.get("GroupId")
            resource_name = result.get("GroupName", resource_id) # Use GroupName if available

        # Add other tool mappings here...

        if resource_id:
            resource_state = ResourceState(
                id=resource_id,
                name=resource_name,
                type=resource_type,
                status="creating",  # Or extract from result if available
                properties=properties
            )
            self.agent.state_manager.add_resource(resource_state)
            self.logger.info(f"Saved new resource '{resource_id}' of type '{resource_type}' to state.")

    async def execute_plan(self, execution_plan: List[Dict[str, Any]]) -> None:
        """
        The main method to execute a given plan. It iterates through steps,
        handles dependencies (in the future), and sends updates.

        Args:
            execution_plan (List[Dict[str, Any]]): The list of steps to execute.
        """
        await self._send_update({"status": "Executing", "message": "Plan execution started"})
        self.logger.info("Plan execution started. Processing steps...")

        for step in execution_plan:
            step_id = step.get("id")
            step_name = step.get("name", "Unnamed Step")
            tool_name = step.get("mcpTool")
            tool_params = step.get("toolParameters", {})
            action = step.get("action", "").lower()

            if not all([step_id, tool_name]):
                raise ValueError(f"Step is missing required fields 'id' or 'mcpTool': {step}")

            self.logger.info(f"--- Preparing to execute step: '{step_name}' (ID: {step_id}) ---")
            await self._send_update({
                "status": "Executing Step",
                "step": step_name,
                "message": f"Executing step: {step_name}"
            })

            try:
                # 1. Resolve parameters for the current step
                resolved_params = self._resolve_placeholders_recursively(tool_params)
                self.logger.info(f"Executing tool '{tool_name}' with resolved params: {resolved_params}")
                
                # 2. Execute the tool via the agent
                result = await self.agent.execute_tool(tool_name, **resolved_params)
                
                # 3. Store the result in the context for subsequent steps
                self.context[step_id] = result
                self.logger.info(f"Step '{step_name}' completed. Result stored in context for ID '{step_id}'.")
                self.logger.debug(f"Context after step '{step_id}': {self.context}")

                # 4. If a resource was created, update the main state
                if action == "create":
                    self._update_state_after_creation(tool_name, result)

                # 5. Send success update to the client
                await self._send_update({
                    "status": "Step Completed",
                    "step": step_name,
                    "result": result
                })

            except Exception as e:
                self.logger.error(f"Execution failed at step '{step_name}': {e}", exc_info=True)
                error_details = {"error": str(e)}
                if isinstance(e, ValueError) and "Debug Info:" in str(e):
                    try:
                        # Extract debug info from the custom ValueError message
                        debug_info_str = str(e).split("Debug Info:")[1].strip()
                        error_details["debug_info"] = json.loads(debug_info_str)
                    except (IndexError, json.JSONDecodeError):
                        pass # Fallback to just the error string if parsing fails

                await self._send_update({
                    "status": "Step Failed",
                    "step": step_name,
                    "result": error_details # Send error_details instead of just str(e)
                })
                # Re-raise the exception to stop the entire plan execution
                raise

        await self._send_update({
            "status": "Execution Completed Successfully",
            "message": "All plan steps executed successfully."
        })
        self.logger.info("Plan execution finished successfully.")